#include <stdio.h>
#include <stdlib.h>
#include <math.h>

void InverseOfMatrix(double** matrix, int order) {
	float temp = 0; // Матричная декларация.
	// Создаем расширенную матрицу. Добавить идентификационную матрицу порядка в конце исходной матрицы.
	for (int i = 0; i < order; i++) {
		for (int j = 0; j < 2 * order; j++) {
			// Добавить '1' в диагональных местах матрицы для создания идентичности matirx
			if (j == (i + order)) matrix[i][j] = 1;
		}
	}
	// Меняем строку матрицы, смена ряда начнется с последнего ряда
	for (int i = order - 1; i > 0; i--) {
		// Меняем местами каждый элемент двух строк
		if (matrix[i - 1][0] < matrix[i][0]) {
			for (int j = 0; j < 2 * order; j++) { // Перестановка строки, если выше условие выполнено.

				temp = matrix[i][j];
				matrix[i][j] = matrix[i - 1][j];
				matrix[i - 1][j] = temp;

			}

		}
	}
	// Заменить строку на сумму самого себя и константа, кратная другой строке матрицы
	for (int i = 0; i < order; i++) {
		for (int j = 0; j < order; j++) {
			if (j != i) {
				temp = matrix[j][i] / matrix[i][i];
				for (int k = 0; k < 2 * order; k++) {
					matrix[j][k] -= matrix[i][k] * temp;
				}
			}
		}
	}
	// Умножаем каждую строку на ненулевое целое число. Делим элемент строки по диагональному элементу
	for (int i = 0; i < order; i++) {
		temp = matrix[i][i];
		for (int j = 0; j < 2 * order; j++) {
			matrix[i][j] = matrix[i][j] / temp;
		}
	}
	for (int i = 0; i < order; i++) {
		for (int j = 0; j < order; j++) {
			matrix[i][j] = matrix[i][j + 4];
		}
	}
	return;

}

double rework_D(char* read) {
	for (int n = 0; n < 20; n++) {
		if (read[n] == 'D') {
			read[n] = 'e';
		}
	}
	return atof(read);
}

void reading_data(FILE* file, int* num_sat, int* date, float* second, double* clock, double** broadcast_orb) {
	char read[20] = { 0 };
	char c = 0;
	for (int i = 0; i < 6; i++) {
		fgets(read, 3, file);
		if (i == 0) num_sat[0] = atoi(read);
		else date[i - 1] = atoi(read);
		if (i != 5) c = fgetc(file);
	}
	fgets(read, 6, file);
	second[0] = atof(read);
	for (int i = 0; i < 3; i++) {
		fgets(read, 20, file);
		clock[i] = rework_D(read);
	}
	for (int i = 0; i < 7; i++) {
		for (int m = 0; m < 4; m++) {	//3 'space'
			c = fgetc(file);
		}
		for (int j = 0; j < 4; j++) {
			if (i == 6 && j == 2) {
				fgets(read, 20, file);
				break;
			}
			fgets(read, 20, file);
			broadcast_orb[i][j] = rework_D(read);
		}
	}
}

void zagolovok(FILE* input, double x[], int kol) {
	char str[80] = { 0 };
	char* istr = NULL;     //указатель на найденное слово
	char* estr = NULL;     //указатель на считанную строку
	char per[17] = { 0 };

	while (1) {
		estr = fgets(str, sizeof(str), input);
		istr = strstr(str, "ANT ");
		if (istr != NULL) {
			for (int i = 0; i < 3; i++) {
				fgets(per, 16, input);
				x[i] = atof(per);
			}
			istr = NULL;
		}
		istr = strstr(str, "TYPES");
		if (istr != NULL) {
			kol = atoi(str);
			istr = NULL;
		}
		istr = strstr(str, "END");
		if (istr != NULL) {
			break;
		}
	}
	return;
}

void find_header(FILE* file) {
	int isfound = 0;
	char word[] = "END OF HEADER", line[100];
	while (fgets(line, 100, file)) if (strstr(line, word)) { ++isfound; break; };
	return;
}

void work_with_data(int* date, float* second, double* clock, double* psd, double** broadcast_orb, int i, double** pns, float Tpr, double** sel_coord, int count) {
	double n = 0, Mk = 0, Ek = 0, dEk = 0, Ok = 0, Fk = 0, dFk = 0, Uk = 0, dUk = 0, Rk = 0, dRk = 0, Ik = 0, dIk = 0, OMEGAk = 0, dOMEGAk = 0, af2 = 0;
	double sel_pos_vector[2] = { 0 };
	double d_sel_pos_vector[2] = { 0 };
	int c = 299792458;
	double omegaZ = 7.2921151467e-5, CR = -4.442807633e-10;
	double X_sp[3] = { 0 };
	double Toc = date[3] * 3600 + date[4] * 60 + second[0];

	Tpr = Tpr - pns[i][1] / c;
	int tk = round(broadcast_orb[2][0] / 86400) * 86400 + Tpr - broadcast_orb[2][0];

	if (tk > 302400) {
		tk -= 604800;
	}
	else if (tk < -302400) {
		tk += 604800;
	}
	n = sqrt((3.986005 * pow(10, 14)) / pow(broadcast_orb[1][3], 6)) + broadcast_orb[0][2];
	Mk = broadcast_orb[0][3] + n * tk;
	Ek = Mk;
	double Ek1 = 0;
	while (fabs(Ek1 - Ek) >= 10E-2) {
		Ek1 = Ek + ((Mk - Ek + broadcast_orb[1][1] * sin(Ek)) / (1 - broadcast_orb[1][1] * cos(Ek)));
		Ek = Ek1;
	}

	dEk = n / (1 - broadcast_orb[1][1] * cos(Ek));
	Ok = atan2((sqrt(1 - pow(broadcast_orb[1][1], 2)) * sin(Ek)), (cos(Ek) - broadcast_orb[1][1]));
	Fk = Ok + broadcast_orb[3][2];
	dFk = (sqrt(1 - pow(broadcast_orb[1][1], 2)) * dEk) / (1 - broadcast_orb[1][1] * cos(Ek));
	Uk = Fk + (broadcast_orb[1][0] * cos(2 * Fk) + broadcast_orb[1][2] * sin(2 * Fk));
	dUk = dFk * (1 + 2 * (broadcast_orb[1][0] * cos(2 * Fk) - broadcast_orb[1][2] * sin(2 * Fk)));
	Rk = pow(broadcast_orb[1][3], 2) * (1 - broadcast_orb[1][1] * cos(Ek)) + (broadcast_orb[3][1] * cos(2 * Fk) + broadcast_orb[0][1] * sin(2 * Fk));
	dRk = pow(broadcast_orb[1][3], 2) * broadcast_orb[1][1] * dEk * sin(Ek) + 2 * dFk * (broadcast_orb[3][1] * cos(2 * Fk) + broadcast_orb[0][1] * sin(2 * Fk));
	Ik = broadcast_orb[3][0] + (broadcast_orb[2][1] * cos(2 * Fk) + broadcast_orb[2][3] * sin(2 * Fk)) + broadcast_orb[4][0] * tk;
	dIk = broadcast_orb[4][0] + 2 * dFk * (broadcast_orb[2][3] * cos(2 * Fk) + broadcast_orb[2][1] * sin(2 * Fk));
	sel_pos_vector[0] = Rk * cos(Uk);
	sel_pos_vector[1] = Rk * sin(Uk);

	d_sel_pos_vector[0] = dRk * cos(Uk) - sel_pos_vector[1] * dUk;
	d_sel_pos_vector[1] = dRk * sin(Uk) - sel_pos_vector[0] * dUk;
	OMEGAk = broadcast_orb[2][2] + (broadcast_orb[3][3] - omegaZ) * tk - omegaZ * broadcast_orb[2][0];
	dOMEGAk = broadcast_orb[3][3] - omegaZ;
	sel_coord[count][0] = sel_pos_vector[0] * cos(OMEGAk) - sel_pos_vector[1] * cos(Ik) * sin(OMEGAk);
	sel_coord[count][1] = sel_pos_vector[0] * sin(OMEGAk) + sel_pos_vector[1] * cos(Ik) * cos(OMEGAk);
	sel_coord[count][2] = sel_pos_vector[1] * sin(Ik);

	
	int Tk = Tpr - Toc;
	double delTr = CR * broadcast_orb[1][1] * broadcast_orb[1][3] * sin(Ek);
	double offset = clock[0] + Tk * (clock[1] + Tk * clock[2]) + delTr - broadcast_orb[5][2];
	psd[count] = pns[i][1] + offset * c;  

	//Коррекция координат НКА, учитывающая вращение Земли за время от момента излучения, на который посчитаны координаты НКА, до Момента приём сигнала
	double Aor = -psd[count] * omegaZ / c;
	double Mor[3][3] = {0, 0, 0, 0, 0, 0, 0, 0, 1};
	Mor[1][1] = cos(Aor);
	Mor[0][0] = cos(Aor);
	Mor[0][1] = sin(Aor);
	Mor[1][0] = -Mor[0][1];
	for (int i = 0; i < 3; i++) {
		for (int j = 0; j < 3; j++) {
			X_sp[i] += sel_coord[count][j] * Mor[j][i];
		}
	}
	for (int i = 0; i < 3; i++) {
		sel_coord[count][i] = X_sp[i];
	}

}

void work_with_matrix(double JK[], int kol_sp, double** J, double** Jt, double F[], int order, double** H, double** K) {
	for (int i = 0; i < order; i++) {
		for (int j = 0; j < kol_sp; j++) {
			K[i][j] = 0;
		}
		for (int k = 0; k < 2*order; k++) {
			H[i][k] = 0;
		}
	}

	for (int i = 0; i < order; i++) {
		for (int j = 0; j < kol_sp; j++) {
			Jt[i][j] = J[j][i];
		}
	}

	for (int i = 0; i < order; i++) {
		for (int j = 0; j < order; j++) {
			for (int k = 0; k < kol_sp; k++) {
				H[i][j] += Jt[i][k] * J[k][j];
			}
		}
	}
	printf("\n");
	InverseOfMatrix(H, order);   
	
	for (int i = 0; i < order; i++) {
		for (int j = 0; j < kol_sp; j++) {
			for (int k = 0; k < order; k++) {
				K[i][j] += H[i][k] * Jt[k][j];
			}			
		}
	}

	for (int i = 0; i < order; i++) {
		for (int j = 0; j < kol_sp; j++) {
			JK[i] += K[i][j] * F[j];			
		}		
	}
	return;
}

void answer(int kol_sp, double** sel_coord, double* psd, double X[]) {
	double** J = (double**)malloc(kol_sp * sizeof(double*));  //матрица производных
	for (int i = 0; i < kol_sp; i++) {
		J[i] = (double*)malloc(4 * sizeof(double));
	}

	double** Jt = (double**)malloc(4 * sizeof(double*));  //транспонированая матрица производных
	for (int i = 0; i < 4; i++) {
		Jt[i] = (double*)malloc(kol_sp * sizeof(double));
	}

	double** K = (double**)malloc(4 * sizeof(double*)); 
	for (int i = 0; i < 4; i++) {
		K[i] = (double*)malloc(kol_sp * sizeof(double));
	}

	double* F = (double*)malloc(kol_sp * sizeof(double)); //матрица значений функций
	for (int i = 0; i < kol_sp; i++) {
		F[i] = 0;
	}

	double** H = (double**)malloc(4 * sizeof(double*));
	for (int i = 0; i < 4; i++) {
		H[i] = (double*)malloc(8 * sizeof(double));
	}

	double JK[4] = { 0 };
	double x[4] = { X[0], X[1], X[2], 0 };
	double eps = 1e-5, min = 0;
	int c = 299792458;
	while (1) {
		for (int i = 0; i < kol_sp; i++) {
			J[i][0] = (sel_coord[i][0] - x[0]) / (sqrt(pow((x[0] - sel_coord[i][0]), 2) + pow((x[1] - sel_coord[i][1]), 2) + pow((x[2] - sel_coord[i][2]), 2)));
			J[i][1] = (sel_coord[i][1] - x[1]) / (sqrt(pow((x[0] - sel_coord[i][0]), 2) + pow((x[1] - sel_coord[i][1]), 2) + pow((x[2] - sel_coord[i][2]), 2)));
			J[i][2] = (sel_coord[i][2] - x[2]) / (sqrt(pow((x[0] - sel_coord[i][0]), 2) + pow((x[1] - sel_coord[i][1]), 2) + pow((x[2] - sel_coord[i][2]), 2)));
			J[i][3] = c;
			F[i] = psd[i] - (sqrt(pow((x[0] - sel_coord[i][0]), 2) + pow((x[1] - sel_coord[i][1]), 2) + pow((x[2] - sel_coord[i][2]), 2))) - x[3] * c;
			
		}

		work_with_matrix(JK, kol_sp, J, Jt, F, 4, H, K);

		for (int i = 0; i < 4; i++) {
			x[i] -= JK[i];
		}
		min = fabs(JK[0]);
		for (int i = 1; i < 4; i++) {
			if (fabs(JK[i]) < min) min = fabs(JK[i]);
		}
		if (min < eps) break;
		
	}

	printf("delX = %f; delY = %f; delZ = %f; delT = %e\n\n", X[0] - x[0], X[1] - x[1], X[2] - x[2], x[3]);
	return;
}

int main() {

	FILE* input;
	char* fileID = "ab010010.20o";

	char* in_sp = "ab010010.20n";
	FILE* file;

	if ((input = fopen(fileID, "r")) == NULL)
	{
		printf("Error opening file");
		exit(EXIT_FAILURE);
	}
	input = fopen(fileID, "r");

	double x[3] = { 0 };  //координаты для проверки
	int kol = 0;        //количество показателей
	float Tpr = 0; //время приема
	int kol_sp = 0;     //количество спутников

	int* date = (int*)malloc(5 * sizeof(int));			 // year, month, day, hour, minute
	float* second = (float*)malloc(1 * sizeof(float));
	double* clock = (double*)malloc(3 * sizeof(double));		// sat_clock, move_clock, boost_clock
	int* num_sat = (int*)malloc(1 * sizeof(int));

	double** broadcast_orb = (double**)malloc(7 * sizeof(double*));// 0) IODE, Crs, delta_n, M0;		1)Cuc, e_orb, Cus, sqrt_A;		2)Toe, Cic, OMEGA, Cis;			3)i0, Crc, omega, OMEGA_DOT;		     	4) IDOT, cod_l2, week_num, inf_posl, data_flag_l2;		  5) loc_acc, serv_sp, TGD, IODC;			6)airtime, approx_inter;
	for (int i = 0; i < 7; i++) {
		broadcast_orb[i] = (double*)malloc(4 * sizeof(double));
	}

	double** sel_coord = (double**)malloc(30 * sizeof(double*)); //координаты спутников
	for (int i = 0; i < 30; i++) {
		sel_coord[i] = (double*)malloc(3 * sizeof(double));
	}
	for (int i = 0; i < 30; i++) {
		for (int j = 0; j < 3; j++) {
			sel_coord[i][j] = 0;
		}
	}

	double** pns = (double**)malloc(30 * sizeof(double*)); //pns[i][0] - номер приемника, pns[i][1] - псевдодальность
	for (int i = 0; i < 30; i++) {
		pns[i] = (double*)malloc(2 * sizeof(double));
	}
	double* psd = (double*)malloc(30 * sizeof(double)); //psd - псевдодальность уточненная
	for (int i = 0; i < 30; i++) {
		psd[i] = 0;
	}


	zagolovok(input, x, kol);         
	printf("%f %f %f", x[0], x[1], x[2]);


	while (!feof(input)) {

		int Hour = 0, Minute = 0;
		float Second = 0;
		char per[17];          //вспомагательная строка

		fgets(per, 12, input);
		fgets(per, 3, input);
		sscanf(per, "%d", &Hour);
		printf(" %d", Hour);
		fgets(per, 4, input);
		sscanf(per, "%d", &Minute);           //время приема
		printf(" %d", Minute);
		fgets(per, 11, input);
		sscanf(per, "%f", &Second);
		printf(" %f", Second);
		fgets(per, 8, input);
		sscanf(per, "%*s %d", &kol_sp);                  //кол-во приемников
		
		Tpr = Hour * 3600 + Minute * 60 + Second;
		for (int i = 0; i < kol_sp; i++) {
			fgets(per, 4, input);    //номера приемников
			pns[i][0] = atoi(per);
		}
		double c = 0;
		double a = 0, b = 0;

		for (int i = 0; i < kol_sp; i++) {
			for (int j = 0; j < 3; j++) {
				fgets(per, 17, input);
				if (j == 2) {
					pns[i][1] = atof(per);      //пcевдодальность
				}
			}

			fgets(per, 14, input);
			c = atof(per);
			if (pns[i][1] - c < 1000) {
				fgets(per, 17, input);
				fgets(per, 17, input);
			}
			fgets(per, 17, input);
		}

		if ((file = fopen(in_sp, "r")) == NULL) {
			printf("file not found!");
			exit(0);
		}
		file = fopen(in_sp, "r");
		int count = 0;
		find_header(file);
		while (!feof(file)) {
			reading_data(file, num_sat, date, second, clock, broadcast_orb);
			if (num_sat[0] == 0) break;
			for (int i = 0; i < kol_sp - count; i++) {
				if (pns[i][0] == num_sat[0]) {
					work_with_data(date, second, clock, psd, broadcast_orb, i, pns, Tpr, sel_coord, count);
					pns[i][0] = pns[kol_sp - (count + 1)][0];
					pns[i][1] = pns[kol_sp - (count + 1)][1];
					count += 1;
				}
				if (count == kol_sp) break;
			}
		}
		answer(kol_sp, sel_coord, psd, x);
		printf("\n\n");
		fclose(file);
	}
} 
